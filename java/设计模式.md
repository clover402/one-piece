# 原则
1. 开闭原则
对扩展开发，对修改封闭
接口 + 抽象类

2. 里氏代换原则
任何基类可以出现的地方，子类一定可以出现

3. 依赖倒转原则
针对接口编程，高层模块不应该依赖底层模块，二者都应该依赖抽象而不依赖具体。
要针对抽象层编程，而不要针对具体类编程

4. 接口隔离原则
使用多个隔离的接口优于单个庞大的接口
低依赖低耦合

5. 单一职责原则
类的职责要单一，不能将太多的职责放在一个类中

6. 最少知道原则
迪米特法则（Demeter Principle）
一个实体应对尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立

7. 合成复用原则
在一个新的对象里通过关联关系来使用一些已有的对象，使之成为新对象的一部分。复合优于继承

# 推荐书籍
1. Head First 设计模式

# 设计模式
1. 工厂模式
一个工厂类用于创建另外一个类的对象
静态多方法工厂类使用得比较多

2. 抽象工厂模式
用于有同样组织结构的几个系列产品，可以针对不同的客户有不同的解决方案。通常会有一个抽象工厂类以及多个子工厂类以实现不同的具体需求

3. 适配器模式
一个已有类的接口与我方类不一样，不能直接使用，这时可以创建一个适配器来解决

4. 装饰者模式
在原有类基础上复合增加新的特性，相当于把特点和特性抽象成类

5. 观察者模式
发布者-订阅模式，源-监听模式
一个目标对象来管理所有依赖与它的观察者对象，并且当这个目标对象自身发生改变时会主动通知观察者们

6. 单例模式
一个类能返回对象的唯一引用和一个获得该实例的唯一方法
饿汉模式 一上来就新建实例
懒汉模式 需要时再新建实例
线程安全懒汉模式 加synchronized修饰 防止多线程时创建多个实例
双重检验锁 只需在第一次创建实例时加同步
```
// 双重锁的 getWife() 方法
public static Wife getWife() {

    // 第一个检验锁，如果不为空直接返回实例对象，为空才进入下一步
    if (wife == null) {
        synchronized (Wife.class) {

            //第二个检验锁，因为可能有多个线程进入到 if 语句内
            if (wife == null) {
                wife = new Wife();
            }
        }
    }
    return wife ;
}
```
volatile关键字
静态内部类
```
// 静态内部类
public class Wife {
    private static class WifeHolder {
        private static final Wife wife = new Wife();
    }

    private Wife() { }

    public static Wife getWife() {
        return WifeHolder.wife;
    }
}
```
枚举
```
// 枚举
public enum Wife {
    INSTANCE;

    // 自定义的其他任意方法
    public void whateverMethod() { }
}
```
