## 属性及常量
### MIN_VALUE
int对java是平台无关，都是4个字节，最小值0x80000000，负的2的32次方，一个1，31个0，最高位为符号位，此处时补码，源码是31个0求反，31个1，即0x7fffffff,再加1，即2的32次方

### MAX_VALUE
最大值0x7fffffff,一个0，31个1，除了符号位0，其他都是1.

### value
原始的标量int值

### SIZE = 32
bit数量

### BYTES = SIZE/ Byte.SIZE
字节数量

## 内部类
### IntegerCache
用于缓存常用的Integer值，默认是-128~127的所有值，如果java.lang.Integer.IntegerCache.high的值大于127，则以此值为准，但是缓存数组的大小不能操作Integer的最大值

## 私有方法
### toUnsignedString0(int val, int shift)
//todo

### stringSize(int x)
返回一个正整数的位数，通过与一个包含9，99...的数组比较,小于数组中某个数时返回对应的index+1，空间换时间。

### getChars(int i, int index, char[] buf)
此方法很有技巧性，先判断符号位，统一转成正整数处理。  
如果数字大于65536(2^16)时，每次取末两位，除以100得到q，求末两位数时不是i%100，而是用位运算i - ((q << 6) + (q << 5) + (q << 2))，即i - (64q + 32q + 4q),实测位运算比乘法效率高，取最后两位数字的时候也是一个小技巧，用了包含100个字符的数组DigitOnes和DigitTens分别来取个位数和十位数，空间换时间的一个技巧。  
如果数字小于65536时，每次取1位，这里不是直接除，而是q = (i * 52429) >>> (16 + 3), 相当于i * 52429 / 524288, 约等于除以10，52429是能用位移进行除法运算的最大值，16位第一位符号位不使用，只使用了最后15位，这样i小于65536时与它相乘不会造成int溢出。实测乘法确实比除法快。再求余数，也是位运算 i - ((q << 3) + (q << 1)).最后使用digits数组取出对于字符放入buff数组。


## 静态方法
### toString(int i, int radix)
将一个int值转化为某进制的字符串  
使用了33位的char数组，因为要包含正负号，如果是负数就可能达到33位.转化成负数进行计算，对原数按进制取余放到数组里，依次从地位到高位，直至原数小于进制。

### toUnsignedString(int i, int radix)
由于第一位不作为符号位了，那实际上真实的数组是会超过int的最大值，此处是用long来处理的

### toHexString/toOctalString/toBinaryString
转16/8/2进制字符串，用的私有方法toUnsignedString0

### toString
转化为10进制。如果为最小值MIN_VALUE，直接返回对应字符串，可见这个数不合常理，是个特例.获取数字需要的字符串长度，负数要多1个符号位，然后调用getChars方法转字符串

### parseInt(String s, int radix)
将字符串按某进制转化成int数字（10进制），进制范围2~36.  
先取符号位，然后按负数进行计算，从左至右按进制取每一位的字符，相当于一个求和的过程，每次先乘进制数，再减对应位上的数，比如:111 8进制相当于(-1\*8 - 1)\*8 - 1。这样很巧妙，乘法运算的次数最少。最后根据符号位再转回原来的值。期间会进行溢出判断，如果超过最大值或者最小值则报异常。

### parseUnsignedInt(String s, int radix)
判断是否有符号位，如果有则抛异常。判断是否在int最大值范围内，如果在使用parseInt处理，否则用Long.parseLong处理，然后再判断4个字节的高位是否存在1，如果则表明溢出，抛异常。

### valueOf(String s, int radix)
先用parseInt转int，然后调用valueOf(int i)实现：如果i在缓存范围内-128~127之间则直接用缓存的值。否则调用构造函数直接创建一个新的Integer类。

### getInteger(String nm, int val)
获取系统属性值nm, 如果获取到了合理值则转int返回，否则返回默认值val

### decode(String nm)
先处理符号位，再处理特殊前缀，0x、0X、#都表示16进制，单0表示8进制，然后调用valueOf转化

### hashCode(int value)
直接返回value值

### equals(Object obj)
判断两对象的value是否相对

### compareUnsinged
把它们作为无符号的int进行比较，都加上MIN_VALUE再进行比较

### toUnsignedLong(int x)
转long再与0xffffffffL进行&操作，相当于高位全是0，低位不变

### highestOneBit(int i)
第一步的作用是把最高位1右移移位，并与原数据按位取或。那么这就使得最高位和它的下一位是连续两个1。  
第二步的作用是把刚刚移位得到连续两个1继续右移两位并与原数据按位取或。那么这就使得最高两位和它的下两个连续位组成四个连续的1。  
以此类推，最终得到的i是从开始的最高位到结束全是1。并减去i不带符号的右移一位，即可得到一个int数据的最高位的值。

### lowestOnebit(int i)
i & -1, 返回二进制最低位1的权值.原理与负数的补码表示有关，由i按位取反再末位加1可以得到-i的补码。
也就是说，这个过程中最低位的1会变成0，其后的0全部变成1，加1后往前进位，
原位置又变回1，(i & -i)运算得到结果。

### numberOfLeadingZeros(int i)
1.判断整型i的值是否为0，如果是，那么表明0的个数为32个，直接返回即可
2.判断i无符号右移16位后的值是否为0.判断的是高16位的第一个非0数字是否存在。
条件成立，则表明第一个非0位在低16位
否则，第一个非零值在高16位。
3.如果前面的判断条件成立，（i>>>16 == 0） 那么进入if里面的语句之后，会将i向左移，将低16位变成高16位，对低16位进行计数。
如果判断不成立，即使非零位在高16为那么就没有必要进行移位的处理
4.后面的判断与第一个类似。
5.n初始化为1，因此，如果判断最后的位为1，那么n减1，否则为i>>>31为0的话，那么就不操作

### bitCount(int i)
```java
public static int bitCount(int i) {
        // HD, Figure 5-2
        i = i - ((i >>> 1) & 0x55555555);
        /**
         *0x33333333其实就是二进制……00110011（共32位），因为上面的每两位代表1的个数，所以下面的这几行就是要把上面每两位
         * 的数字加起来，下面的这行代码可以这样理解，每4位分为一组，然后4位中的每两位相加，相加的结果在储存到这4位二进制数中，
         * i & 0x33333333表示每4位中的低2位，(i >>> 2) & 0x33333333表示每4位中的高2位，然后在相加
         */
        i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);
        /**
         * 这个更好理解，i >>> 4表示往右移动了4位，然后在与i相加，相当于每8位一组，然后8位中的高4位与低4位相加储存在低4位中，
         * 然后这里在与0x0f0f0f0f进行与运算，把高4位完全置为0了，因为0x0f0f0f0f用二进制表示就是00001111000011110000111100001111，
         * 看到这里可能有些困惑，这里为什么要与0x0f0f0f0f进行与运算，因为每8位一组的话，最多也就是8，那么4位数足够了，高4位就没有必要了，
         * 如果不置为0有没有影响，其实如果1的位数极少的话是没什么影响的，但如果1的位数比较多到后面计算的结果可能就会往前进位，导致结果错误，
         * 所以这一步要进行一次与运算，那为什么上面的那行代码没有把4位一组中的高两位置0，这是因为4位一组最多有4个1，而2位二进制数最多表示3，
         * 小于4，所以不能置为0，
         *
         */
        i = (i + (i >>> 4)) & 0x0f0f0f0f;
        /**
         * 和上面类似，每16位分为一组，每组中的高8位和低8位相加，这里的代码相加的很干净，因为无论是高8位还是低8位中的前4位在上面一行中
         * 都已经置为0了，这里也可以像上面那样，加完之后在与0x00ff00ff进行与运算，但其实这里已经没有必要了，因为int类型为32位，
         * 最多也就32个1，用8位数储存足够了，所以不会超过8位，也就不用担心超过8位在往前进1位的问题了。
         */
        i = i + (i >>> 8);
        i = i + (i >>> 16);
        /**
         * 到最后为什么要和0x3f进行与运算，0x3f用二进制表示就是111111,因为上面两行没有进行与运算，所以前面的数据都是无效的，
         * 只有最后8位是有效的，而后8位的前两位不用说肯定为0，因为最多也就32个1，用后面6位数表示就已经足够了，所以这里与0x3f
         * 进行与运算，来计算出最终1的个数
         */
        return i & 0x3f;
}
```
第一行，每两位一组，把原来单元中1的个数储存在原来的单元中。
* 00 -> 00减去偶数位上的数0  结果00，表示0个1
* 01 -> 01减去偶数位上的数0  结果01，表示1个1
* 10 -> 10减去偶数位上的数1  结果01，表示1个1
* 11 -> 11减去偶数位上的数1  结果10，表示2个1

### reverse(int i)
将bit位反转
```java
 public static int reverse(int i) {
        // HD, Figure 7-1
        //奇偶位互换位置
        i = (i & 0x55555555) << 1 | (i >>> 1) & 0x55555555;
        //两位一组互换位置
        i = (i & 0x33333333) << 2 | (i >>> 2) & 0x33333333;
        //四位一组互换位置
        i = (i & 0x0f0f0f0f) << 4 | (i >>> 4) & 0x0f0f0f0f;
        //八位一组，1234字节变成4321字节
        i = (i << 24) | ((i & 0xff00) << 8) |
            ((i >>> 8) & 0xff00) | (i >>> 24);
        return i;
    }
```

### signum(int i)
（i >> 31) | (-i >>> 31) ，获取i正负属性，大于0返回1，小于0返回-1，等于0返回0. >>带符号右移，>>>无符号右移。当i为正数时，左边为0，右边为1，最终为1.当1为负数时左边为全1，右边为0，最终为-1.

### reverseBytes(int i)
字节反转，字节1234, 1移到4的位置（无符号移动），2移到3的位置，3移到2的位置，4移到1的位置
